{"file_contents":{"services/ai_insights.py":{"content":"from app import db\nfrom models.transaction import Transaction\nfrom sqlalchemy import func, extract\nfrom datetime import datetime, date, timedelta\nfrom calendar import month_name\n\n\ndef get_spending_trend(user_id, months=3):\n    today = date.today()\n    monthly_spending = []\n    \n    for i in range(months, 0, -1):\n        month_ago = today - timedelta(days=30 * i)\n        start_of_month = date(month_ago.year, month_ago.month, 1)\n        \n        if month_ago.month == 12:\n            next_month = date(month_ago.year + 1, 1, 1)\n        else:\n            next_month = date(month_ago.year, month_ago.month + 1, 1)\n        \n        spent = db.session.query(func.sum(Transaction.amount)).filter(\n            Transaction.user_id == user_id,\n            Transaction.transaction_type == 'expense',\n            Transaction.date >= start_of_month,\n            Transaction.date < next_month\n        ).scalar() or 0.0\n        \n        monthly_spending.append(spent)\n    \n    if len(monthly_spending) >= 2:\n        trend = monthly_spending[-1] - monthly_spending[-2]\n        return trend, monthly_spending[-1]\n    \n    return 0, monthly_spending[-1] if monthly_spending else 0\n\n\ndef get_savings_recommendation(user_id, total_income, total_expense):\n    if total_income <= 0:\n        return None\n    \n    savings_rate = ((total_income - total_expense) / total_income) * 100\n    \n    if savings_rate < 10:\n        return \"Aim to save at least 10% of your income. Start by identifying one category to reduce spending.\"\n    elif savings_rate < 20:\n        return \"You're saving {:.1f}% - good start! Try to reach 20% by cutting discretionary expenses.\".format(savings_rate)\n    elif savings_rate < 30:\n        return \"Great savings rate of {:.1f}%! Consider increasing to 30% for long-term financial security.\".format(savings_rate)\n    else:\n        return \"Excellent {:.1f}% savings rate! You're building strong financial habits.\".format(savings_rate)\n\n\ndef analyze_seasonal_spending(user_id):\n    today = date.today()\n    current_month = today.month\n    \n    current_month_spending = db.session.query(func.sum(Transaction.amount)).filter(\n        Transaction.user_id == user_id,\n        Transaction.transaction_type == 'expense',\n        extract('month', Transaction.date) == current_month\n    ).scalar() or 0.0\n    \n    avg_spending = db.session.query(func.avg(Transaction.amount)).filter(\n        Transaction.user_id == user_id,\n        Transaction.transaction_type == 'expense'\n    ).scalar() or 0.0\n    \n    all_months = db.session.query(\n        extract('month', Transaction.date).label('month'),\n        func.sum(Transaction.amount).label('total')\n    ).filter(\n        Transaction.user_id == user_id,\n        Transaction.transaction_type == 'expense'\n    ).group_by(extract('month', Transaction.date)).all()\n    \n    if len(all_months) >= 2:\n        month_totals = {int(m[0]): float(m[1]) for m in all_months}\n        if current_month in month_totals:\n            highest_month = max(month_totals, key=month_totals.get)\n            lowest_month = min(month_totals, key=month_totals.get)\n            \n            if highest_month != lowest_month:\n                return {\n                    'highest_month': month_name[highest_month],\n                    'highest_amount': month_totals[highest_month],\n                    'lowest_month': month_name[lowest_month],\n                    'lowest_amount': month_totals[lowest_month]\n                }\n    \n    return None\n\n\ndef get_ai_insights(user_id):\n    insights = []\n    \n    total_income = db.session.query(func.sum(Transaction.amount)).filter(\n        Transaction.user_id == user_id,\n        Transaction.transaction_type == 'income'\n    ).scalar() or 0.0\n    \n    total_expense = db.session.query(func.sum(Transaction.amount)).filter(\n        Transaction.user_id == user_id,\n        Transaction.transaction_type == 'expense'\n    ).scalar() or 0.0\n    \n    if total_expense > total_income:\n        insights.append({\n            'type': 'warning',\n            'message': 'High spending alert! Your expenses exceed your income.',\n            'icon': 'âš ï¸'\n        })\n    elif total_income > total_expense:\n        savings = total_income - total_expense\n        savings_rate = (savings / total_income * 100) if total_income > 0 else 0\n        insights.append({\n            'type': 'success',\n            'message': f'Great job! You\\'re saving â‚¹{savings:.2f} ({savings_rate:.1f}% of income).',\n            'icon': 'âœ…'\n        })\n    \n    category_data = db.session.query(\n        Transaction.category,\n        func.sum(Transaction.amount).label('total')\n    ).filter(\n        Transaction.user_id == user_id,\n        Transaction.transaction_type == 'expense'\n    ).group_by(Transaction.category).order_by(func.sum(Transaction.amount).desc()).all()\n    \n    if category_data:\n        top_category = category_data[0]\n        insights.append({\n            'type': 'info',\n            'message': f'Your top spending category is \"{top_category[0]}\" with â‚¹{top_category[1]:.2f}.',\n            'icon': 'ðŸ“Š'\n        })\n    \n    transaction_count = Transaction.query.filter_by(user_id=user_id).count()\n    \n    if transaction_count == 0:\n        insights.append({\n            'type': 'info',\n            'message': 'Start tracking your finances by adding your first transaction!',\n            'icon': 'ðŸš€'\n        })\n    elif transaction_count < 5:\n        insights.append({\n            'type': 'info',\n            'message': 'Add more transactions to get better financial insights.',\n            'icon': 'ðŸ’¡'\n        })\n    \n    if total_income > 0 and total_expense > 0:\n        expense_ratio = (total_expense / total_income * 100)\n        if expense_ratio < 50:\n            insights.append({\n                'type': 'success',\n                'message': f'Excellent! You\\'re only spending {expense_ratio:.1f}% of your income.',\n                'icon': 'ðŸŒŸ'\n            })\n        elif expense_ratio > 90:\n            insights.append({\n                'type': 'warning',\n                'message': f'You\\'re spending {expense_ratio:.1f}% of your income. Consider reducing expenses.',\n                'icon': 'ðŸ’°'\n            })\n    \n    trend, current_month_spending = get_spending_trend(user_id, months=3)\n    if abs(trend) > 50:\n        if trend > 0:\n            insights.append({\n                'type': 'warning',\n                'message': f'Spending trend: Your expenses increased by â‚¹{abs(trend):.2f} compared to last month.',\n                'icon': 'ðŸ“ˆ'\n            })\n        else:\n            insights.append({\n                'type': 'success',\n                'message': f'Spending trend: Great! You reduced expenses by â‚¹{abs(trend):.2f} compared to last month.',\n                'icon': 'ðŸ“‰'\n            })\n    \n    savings_tip = get_savings_recommendation(user_id, total_income, total_expense)\n    if savings_tip:\n        insights.append({\n            'type': 'info',\n            'message': f'Savings tip: {savings_tip}',\n            'icon': 'ðŸ’¡'\n        })\n    \n    seasonal_data = analyze_seasonal_spending(user_id)\n    if seasonal_data:\n        difference = seasonal_data['highest_amount'] - seasonal_data['lowest_amount']\n        insights.append({\n            'type': 'info',\n            'message': f'Seasonal insight: Your highest spending was in {seasonal_data[\"highest_month\"]} (â‚¹{seasonal_data[\"highest_amount\"]:.2f}), lowest in {seasonal_data[\"lowest_month\"]} (â‚¹{seasonal_data[\"lowest_amount\"]:.2f}).',\n            'icon': 'ðŸ“…'\n        })\n    \n    if category_data and len(category_data) >= 2:\n        top_two = category_data[:2]\n        combined_spending = top_two[0][1] + top_two[1][1]\n        if total_expense > 0:\n            percentage = (combined_spending / total_expense) * 100\n            if percentage > 60:\n                insights.append({\n                    'type': 'info',\n                    'message': f'{percentage:.0f}% of your spending is on {top_two[0][0]} and {top_two[1][0]}. Consider diversifying or optimizing these categories.',\n                    'icon': 'ðŸŽ¯'\n                })\n    \n    if not insights:\n        insights.append({\n            'type': 'info',\n            'message': 'Keep tracking your transactions for personalized insights!',\n            'icon': 'ðŸ“ˆ'\n        })\n    \n    return insights\n","size_bytes":8329},"routes/dashboard.py":{"content":"from flask import Blueprint, render_template, request, redirect, url_for, flash\nfrom flask_login import login_required, current_user\nfrom app import db\nfrom models.transaction import Transaction\nfrom services.ai_insights import get_ai_insights\nfrom services.pdf_parser import parse_transaction_pdf\nfrom datetime import datetime\nfrom sqlalchemy import func, extract\nimport os\nfrom werkzeug.utils import secure_filename\n\ndashboard_bp = Blueprint('dashboard', __name__)\n\n\n@dashboard_bp.route('/dashboard')\n@login_required\ndef index():\n    transactions = Transaction.query.filter_by(user_id=current_user.id).order_by(Transaction.date.desc()).limit(10).all()\n    \n    total_income = db.session.query(func.sum(Transaction.amount)).filter(\n        Transaction.user_id == current_user.id,\n        Transaction.transaction_type == 'income'\n    ).scalar() or 0.0\n    \n    total_expense = db.session.query(func.sum(Transaction.amount)).filter(\n        Transaction.user_id == current_user.id,\n        Transaction.transaction_type == 'expense'\n    ).scalar() or 0.0\n    \n    balance = total_income - total_expense\n    \n    category_data = db.session.query(\n        Transaction.category,\n        func.sum(Transaction.amount).label('total')\n    ).filter(\n        Transaction.user_id == current_user.id,\n        Transaction.transaction_type == 'expense'\n    ).group_by(Transaction.category).all()\n    \n    categories = [cat[0] for cat in category_data]\n    amounts = [float(cat[1]) for cat in category_data]\n    \n    monthly_data = db.session.query(\n        extract('month', Transaction.date).label('month'),\n        func.sum(Transaction.amount).label('total')\n    ).filter(\n        Transaction.user_id == current_user.id,\n        Transaction.transaction_type == 'expense'\n    ).group_by(extract('month', Transaction.date)).order_by('month').all()\n    \n    months = [f\"Month {int(m[0])}\" for m in monthly_data]\n    monthly_amounts = [float(m[1]) for m in monthly_data]\n    \n    insights = get_ai_insights(current_user.id)\n    \n    return render_template('dashboard.html',\n                         transactions=transactions,\n                         total_income=total_income,\n                         total_expense=total_expense,\n                         balance=balance,\n                         categories=categories,\n                         amounts=amounts,\n                         months=months,\n                         monthly_amounts=monthly_amounts,\n                         insights=insights)\n\n\n@dashboard_bp.route('/add-transaction', methods=['GET', 'POST'])\n@login_required\ndef add_transaction():\n    if request.method == 'POST':\n        transaction_type = request.form.get('transaction_type')\n        category = request.form.get('category')\n        amount = request.form.get('amount')\n        description = request.form.get('description')\n        date_str = request.form.get('date')\n        \n        if not transaction_type or not category or not amount or not date_str:\n            flash('All fields except description are required.', 'danger')\n            return render_template('add_transaction.html')\n        \n        try:\n            amount = float(amount)\n            if amount <= 0:\n                flash('Amount must be greater than zero.', 'danger')\n                return render_template('add_transaction.html')\n        except ValueError:\n            flash('Invalid amount format.', 'danger')\n            return render_template('add_transaction.html')\n        \n        try:\n            date_obj = datetime.strptime(date_str, '%Y-%m-%d').date()\n        except ValueError:\n            flash('Invalid date format.', 'danger')\n            return render_template('add_transaction.html')\n        \n        transaction = Transaction(\n            user_id=current_user.id,\n            transaction_type=transaction_type,\n            category=category,\n            amount=amount,\n            description=description,\n            date=date_obj\n        )\n        \n        db.session.add(transaction)\n        db.session.commit()\n        \n        flash('Transaction added successfully!', 'success')\n        return redirect(url_for('dashboard.index'))\n    \n    return render_template('add_transaction.html')\n\n\n@dashboard_bp.route('/upload-pdf', methods=['GET', 'POST'])\n@login_required\ndef upload_pdf():\n    if request.method == 'POST':\n        if 'pdf_file' not in request.files:\n            flash('No file selected.', 'danger')\n            return redirect(request.url)\n        \n        file = request.files['pdf_file']\n        \n        if file.filename == '':\n            flash('No file selected.', 'danger')\n            return redirect(request.url)\n        \n        if not file.filename.lower().endswith('.pdf'):\n            flash('Only PDF files are allowed.', 'danger')\n            return redirect(request.url)\n        \n        try:\n            transactions = parse_transaction_pdf(file)\n            \n            if not transactions:\n                flash('No transactions found in the PDF. Please check the file format.', 'warning')\n                return redirect(request.url)\n            \n            added_count = 0\n            for trans_data in transactions:\n                transaction = Transaction(\n                    user_id=current_user.id,\n                    transaction_type=trans_data['transaction_type'],\n                    category=trans_data['category'],\n                    amount=trans_data['amount'],\n                    description=trans_data['description'],\n                    date=trans_data['date']\n                )\n                db.session.add(transaction)\n                added_count += 1\n            \n            db.session.commit()\n            \n            flash(f'Successfully imported {added_count} transactions from PDF!', 'success')\n            return redirect(url_for('dashboard.index'))\n        \n        except Exception as e:\n            flash(f'Error processing PDF: {str(e)}', 'danger')\n            return redirect(request.url)\n    \n    return render_template('upload_pdf.html')\n\n\n@dashboard_bp.route('/transactions')\n@login_required\ndef all_transactions():\n    transactions = Transaction.query.filter_by(user_id=current_user.id).order_by(Transaction.date.desc()).all()\n    return render_template('transactions.html', transactions=transactions)\n\n\n@dashboard_bp.route('/edit-transaction/<int:transaction_id>', methods=['GET', 'POST'])\n@login_required\ndef edit_transaction(transaction_id):\n    transaction = Transaction.query.get_or_404(transaction_id)\n    \n    if transaction.user_id != current_user.id:\n        flash('You do not have permission to edit this transaction.', 'danger')\n        return redirect(url_for('dashboard.all_transactions'))\n    \n    if request.method == 'POST':\n        transaction_type = request.form.get('transaction_type')\n        category = request.form.get('category')\n        amount = request.form.get('amount')\n        description = request.form.get('description')\n        date_str = request.form.get('date')\n        \n        if not transaction_type or not category or not amount or not date_str:\n            flash('All fields except description are required.', 'danger')\n            return render_template('edit_transaction.html', transaction=transaction)\n        \n        try:\n            amount = float(amount)\n            if amount <= 0:\n                flash('Amount must be greater than zero.', 'danger')\n                return render_template('edit_transaction.html', transaction=transaction)\n        except ValueError:\n            flash('Invalid amount format.', 'danger')\n            return render_template('edit_transaction.html', transaction=transaction)\n        \n        try:\n            date_obj = datetime.strptime(date_str, '%Y-%m-%d').date()\n        except ValueError:\n            flash('Invalid date format.', 'danger')\n            return render_template('edit_transaction.html', transaction=transaction)\n        \n        transaction.transaction_type = transaction_type\n        transaction.category = category\n        transaction.amount = amount\n        transaction.description = description\n        transaction.date = date_obj\n        \n        db.session.commit()\n        \n        flash('Transaction updated successfully!', 'success')\n        return redirect(url_for('dashboard.all_transactions'))\n    \n    return render_template('edit_transaction.html', transaction=transaction)\n\n\n@dashboard_bp.route('/delete-transaction/<int:transaction_id>', methods=['POST'])\n@login_required\ndef delete_transaction(transaction_id):\n    transaction = Transaction.query.get_or_404(transaction_id)\n    \n    if transaction.user_id != current_user.id:\n        flash('You do not have permission to delete this transaction.', 'danger')\n        return redirect(url_for('dashboard.all_transactions'))\n    \n    db.session.delete(transaction)\n    db.session.commit()\n    \n    flash('Transaction deleted successfully!', 'success')\n    return redirect(url_for('dashboard.all_transactions'))\n","size_bytes":8951},"routes/budgets.py":{"content":"from flask import Blueprint, render_template, request, redirect, url_for, flash\nfrom flask_login import login_required, current_user\nfrom app import db\nfrom models.budget import Budget\nfrom models.transaction import Transaction\nfrom sqlalchemy import func, extract\nfrom datetime import datetime, date, timedelta\nfrom calendar import monthrange\n\nbudgets_bp = Blueprint('budgets', __name__)\n\n\ndef get_budget_spending(user_id, category, period='monthly'):\n    today = date.today()\n    \n    if period == 'monthly':\n        start_date = date(today.year, today.month, 1)\n        _, last_day = monthrange(today.year, today.month)\n        end_date = date(today.year, today.month, last_day)\n    elif period == 'weekly':\n        start_date = today - timedelta(days=today.weekday())\n        end_date = start_date + timedelta(days=6)\n    else:\n        start_date = date(today.year, 1, 1)\n        end_date = date(today.year, 12, 31)\n    \n    spent = db.session.query(func.sum(Transaction.amount)).filter(\n        Transaction.user_id == user_id,\n        Transaction.category == category,\n        Transaction.transaction_type == 'expense',\n        Transaction.date >= start_date,\n        Transaction.date <= end_date\n    ).scalar() or 0.0\n    \n    return spent\n\n\n@budgets_bp.route('/budgets')\n@login_required\ndef index():\n    budgets = Budget.query.filter_by(user_id=current_user.id).all()\n    \n    budget_data = []\n    for budget in budgets:\n        spent = get_budget_spending(current_user.id, budget.category, budget.period)\n        percentage = (spent / budget.amount * 100) if budget.amount > 0 else 0\n        status = 'danger' if spent > budget.amount else 'warning' if percentage > 80 else 'success'\n        \n        budget_data.append({\n            'budget': budget,\n            'spent': spent,\n            'remaining': budget.amount - spent,\n            'percentage': percentage,\n            'status': status\n        })\n    \n    return render_template('budgets.html', budget_data=budget_data)\n\n\n@budgets_bp.route('/budgets/add', methods=['GET', 'POST'])\n@login_required\ndef add_budget():\n    if request.method == 'POST':\n        category = request.form.get('category')\n        amount = request.form.get('amount')\n        period = request.form.get('period', 'monthly')\n        \n        if not category or not amount:\n            flash('Category and amount are required.', 'danger')\n            return render_template('add_budget.html')\n        \n        try:\n            amount = float(amount)\n            if amount <= 0:\n                flash('Amount must be greater than zero.', 'danger')\n                return render_template('add_budget.html')\n        except ValueError:\n            flash('Invalid amount format.', 'danger')\n            return render_template('add_budget.html')\n        \n        existing = Budget.query.filter_by(\n            user_id=current_user.id,\n            category=category,\n            period=period\n        ).first()\n        \n        if existing:\n            flash(f'A {period} budget for {category} already exists. Please edit it instead.', 'danger')\n            return render_template('add_budget.html')\n        \n        budget = Budget(\n            user_id=current_user.id,\n            category=category,\n            amount=amount,\n            period=period\n        )\n        \n        db.session.add(budget)\n        db.session.commit()\n        \n        flash('Budget created successfully!', 'success')\n        return redirect(url_for('budgets.index'))\n    \n    return render_template('add_budget.html')\n\n\n@budgets_bp.route('/budgets/edit/<int:budget_id>', methods=['GET', 'POST'])\n@login_required\ndef edit_budget(budget_id):\n    budget = Budget.query.get_or_404(budget_id)\n    \n    if budget.user_id != current_user.id:\n        flash('You do not have permission to edit this budget.', 'danger')\n        return redirect(url_for('budgets.index'))\n    \n    if request.method == 'POST':\n        amount = request.form.get('amount')\n        period = request.form.get('period')\n        \n        if not amount:\n            flash('Amount is required.', 'danger')\n            return render_template('edit_budget.html', budget=budget)\n        \n        try:\n            amount = float(amount)\n            if amount <= 0:\n                flash('Amount must be greater than zero.', 'danger')\n                return render_template('edit_budget.html', budget=budget)\n        except ValueError:\n            flash('Invalid amount format.', 'danger')\n            return render_template('edit_budget.html', budget=budget)\n        \n        budget.amount = amount\n        budget.period = period\n        \n        db.session.commit()\n        \n        flash('Budget updated successfully!', 'success')\n        return redirect(url_for('budgets.index'))\n    \n    return render_template('edit_budget.html', budget=budget)\n\n\n@budgets_bp.route('/budgets/delete/<int:budget_id>', methods=['POST'])\n@login_required\ndef delete_budget(budget_id):\n    budget = Budget.query.get_or_404(budget_id)\n    \n    if budget.user_id != current_user.id:\n        flash('You do not have permission to delete this budget.', 'danger')\n        return redirect(url_for('budgets.index'))\n    \n    db.session.delete(budget)\n    db.session.commit()\n    \n    flash('Budget deleted successfully!', 'success')\n    return redirect(url_for('budgets.index'))\n","size_bytes":5324},"routes/__init__.py":{"content":"from routes.auth import auth_bp\nfrom routes.dashboard import dashboard_bp\nfrom routes.api import api_bp\nfrom routes.budgets import budgets_bp\nfrom routes.reports import reports_bp\nfrom routes.recurring import recurring_bp\n\n__all__ = ['auth_bp', 'dashboard_bp', 'api_bp', 'budgets_bp', 'reports_bp', 'recurring_bp']\n","size_bytes":315},"app.py":{"content":"import os\nfrom flask import Flask, redirect, url_for, render_template\nfrom flask_sqlalchemy import SQLAlchemy\nfrom flask_login import LoginManager, current_user\nfrom sqlalchemy.orm import DeclarativeBase\nfrom werkzeug.middleware.proxy_fix import ProxyFix\n\n\nclass Base(DeclarativeBase):\n    pass\n\n\ndb = SQLAlchemy(model_class=Base)\nlogin_manager = LoginManager()\n\n\ndef create_app():\n    app = Flask(__name__)\n    app.config.from_object('config.Config')\n    \n    app.wsgi_app = ProxyFix(app.wsgi_app, x_proto=1, x_host=1)\n    \n    db.init_app(app)\n    login_manager.init_app(app)\n    login_manager.login_view = 'auth.login'\n    login_manager.login_message = 'Please log in to access this page.'\n    login_manager.login_message_category = 'info'\n    \n    from models.user import User\n    \n    @login_manager.user_loader\n    def load_user(user_id):\n        return User.query.get(int(user_id))\n    \n    from routes.auth import auth_bp\n    from routes.dashboard import dashboard_bp\n    from routes.api import api_bp\n    from routes.budgets import budgets_bp\n    from routes.reports import reports_bp\n    from routes.recurring import recurring_bp\n    \n    app.register_blueprint(auth_bp)\n    app.register_blueprint(dashboard_bp)\n    app.register_blueprint(api_bp)\n    app.register_blueprint(budgets_bp)\n    app.register_blueprint(reports_bp)\n    app.register_blueprint(recurring_bp)\n    \n    @app.route('/')\n    def index():\n        if current_user.is_authenticated:\n            return redirect(url_for('dashboard.index'))\n        return render_template('landing.html')\n    \n    with app.app_context():\n        import models\n        db.create_all()\n    \n    return app\n\n\napp = create_app()\n","size_bytes":1683},"models/budget.py":{"content":"from app import db\nfrom datetime import datetime\n\n\nclass Budget(db.Model):\n    __tablename__ = 'budgets'\n    \n    id = db.Column(db.Integer, primary_key=True)\n    user_id = db.Column(db.Integer, db.ForeignKey('users.id'), nullable=False, index=True)\n    category = db.Column(db.String(50), nullable=False)\n    amount = db.Column(db.Float, nullable=False)\n    period = db.Column(db.String(20), nullable=False, default='monthly')\n    created_at = db.Column(db.DateTime, default=datetime.utcnow)\n    \n    __table_args__ = (\n        db.UniqueConstraint('user_id', 'category', 'period', name='unique_user_category_period'),\n    )\n    \n    def to_dict(self):\n        return {\n            'id': self.id,\n            'user_id': self.user_id,\n            'category': self.category,\n            'amount': self.amount,\n            'period': self.period,\n            'created_at': self.created_at.isoformat() if self.created_at else None\n        }\n    \n    def __repr__(self):\n        return f'<Budget {self.id} - {self.category} ${self.amount} ({self.period})>'\n","size_bytes":1051},"models/transaction.py":{"content":"from app import db\nfrom datetime import datetime\n\n\nclass Transaction(db.Model):\n    __tablename__ = 'transactions'\n    \n    id = db.Column(db.Integer, primary_key=True)\n    user_id = db.Column(db.Integer, db.ForeignKey('users.id'), nullable=False, index=True)\n    amount = db.Column(db.Float, nullable=False)\n    category = db.Column(db.String(50), nullable=False)\n    transaction_type = db.Column(db.String(20), nullable=False)\n    date = db.Column(db.Date, nullable=False, default=datetime.utcnow().date, index=True)\n    description = db.Column(db.Text)\n    created_at = db.Column(db.DateTime, default=datetime.utcnow)\n    \n    def to_dict(self):\n        return {\n            'id': self.id,\n            'user_id': self.user_id,\n            'amount': self.amount,\n            'category': self.category,\n            'transaction_type': self.transaction_type,\n            'date': self.date.isoformat() if self.date else None,\n            'description': self.description,\n            'created_at': self.created_at.isoformat() if self.created_at else None\n        }\n    \n    def __repr__(self):\n        return f'<Transaction {self.id} - {self.transaction_type} ${self.amount}>'\n","size_bytes":1175},"pyproject.toml":{"content":"[project]\nname = \"repl-nix-workspace\"\nversion = \"0.1.0\"\ndescription = \"Add your description here\"\nrequires-python = \">=3.11\"\ndependencies = [\n    \"email-validator>=2.3.0\",\n    \"flask>=3.1.2\",\n    \"flask-login>=0.6.3\",\n    \"flask-sqlalchemy>=3.1.1\",\n    \"gunicorn>=23.0.0\",\n    \"psycopg2-binary>=2.9.11\",\n    \"pypdf>=6.3.0\",\n    \"python-dateutil>=2.9.0.post0\",\n    \"sqlalchemy>=2.0.44\",\n    \"werkzeug>=3.1.3\",\n]\n","size_bytes":411},"routes/recurring.py":{"content":"from flask import Blueprint, render_template, request, redirect, url_for, flash\nfrom flask_login import login_required, current_user\nfrom app import db\nfrom models.recurring_transaction import RecurringTransaction\nfrom datetime import datetime, date\n\nrecurring_bp = Blueprint('recurring', __name__)\n\n\n@recurring_bp.route('/recurring')\n@login_required\ndef index():\n    recurring_transactions = RecurringTransaction.query.filter_by(user_id=current_user.id).order_by(RecurringTransaction.start_date.desc()).all()\n    \n    recurring_data = []\n    for rt in recurring_transactions:\n        next_date = rt.get_next_date() if rt.is_active else None\n        recurring_data.append({\n            'recurring': rt,\n            'next_date': next_date\n        })\n    \n    return render_template('recurring_transactions.html', recurring_data=recurring_data)\n\n\n@recurring_bp.route('/recurring/add', methods=['GET', 'POST'])\n@login_required\ndef add_recurring():\n    if request.method == 'POST':\n        transaction_type = request.form.get('transaction_type')\n        category = request.form.get('category')\n        amount = request.form.get('amount')\n        description = request.form.get('description')\n        frequency = request.form.get('frequency')\n        start_date_str = request.form.get('start_date')\n        end_date_str = request.form.get('end_date')\n        \n        if not all([transaction_type, category, amount, frequency, start_date_str]):\n            flash('All fields except end date and description are required.', 'danger')\n            return render_template('add_recurring.html')\n        \n        try:\n            amount = float(amount)\n            if amount <= 0:\n                flash('Amount must be greater than zero.', 'danger')\n                return render_template('add_recurring.html')\n        except ValueError:\n            flash('Invalid amount format.', 'danger')\n            return render_template('add_recurring.html')\n        \n        try:\n            start_date = datetime.strptime(start_date_str, '%Y-%m-%d').date()\n        except ValueError:\n            flash('Invalid start date format.', 'danger')\n            return render_template('add_recurring.html')\n        \n        end_date = None\n        if end_date_str:\n            try:\n                end_date = datetime.strptime(end_date_str, '%Y-%m-%d').date()\n                if end_date < start_date:\n                    flash('End date must be after start date.', 'danger')\n                    return render_template('add_recurring.html')\n            except ValueError:\n                flash('Invalid end date format.', 'danger')\n                return render_template('add_recurring.html')\n        \n        recurring = RecurringTransaction(\n            user_id=current_user.id,\n            transaction_type=transaction_type,\n            category=category,\n            amount=amount,\n            description=description,\n            frequency=frequency,\n            start_date=start_date,\n            end_date=end_date,\n            is_active=True\n        )\n        \n        db.session.add(recurring)\n        db.session.commit()\n        \n        flash('Recurring transaction created successfully!', 'success')\n        return redirect(url_for('recurring.index'))\n    \n    return render_template('add_recurring.html')\n\n\n@recurring_bp.route('/recurring/edit/<int:recurring_id>', methods=['GET', 'POST'])\n@login_required\ndef edit_recurring(recurring_id):\n    recurring = RecurringTransaction.query.get_or_404(recurring_id)\n    \n    if recurring.user_id != current_user.id:\n        flash('You do not have permission to edit this recurring transaction.', 'danger')\n        return redirect(url_for('recurring.index'))\n    \n    if request.method == 'POST':\n        amount = request.form.get('amount')\n        description = request.form.get('description')\n        frequency = request.form.get('frequency')\n        end_date_str = request.form.get('end_date')\n        is_active = request.form.get('is_active') == 'on'\n        \n        if not all([amount, frequency]):\n            flash('Amount and frequency are required.', 'danger')\n            return render_template('edit_recurring.html', recurring=recurring)\n        \n        try:\n            amount = float(amount)\n            if amount <= 0:\n                flash('Amount must be greater than zero.', 'danger')\n                return render_template('edit_recurring.html', recurring=recurring)\n        except ValueError:\n            flash('Invalid amount format.', 'danger')\n            return render_template('edit_recurring.html', recurring=recurring)\n        \n        end_date = None\n        if end_date_str:\n            try:\n                end_date = datetime.strptime(end_date_str, '%Y-%m-%d').date()\n                if end_date < recurring.start_date:\n                    flash('End date must be after start date.', 'danger')\n                    return render_template('edit_recurring.html', recurring=recurring)\n            except ValueError:\n                flash('Invalid end date format.', 'danger')\n                return render_template('edit_recurring.html', recurring=recurring)\n        \n        recurring.amount = amount\n        recurring.description = description\n        recurring.frequency = frequency\n        recurring.end_date = end_date\n        recurring.is_active = is_active\n        \n        db.session.commit()\n        \n        flash('Recurring transaction updated successfully!', 'success')\n        return redirect(url_for('recurring.index'))\n    \n    return render_template('edit_recurring.html', recurring=recurring)\n\n\n@recurring_bp.route('/recurring/delete/<int:recurring_id>', methods=['POST'])\n@login_required\ndef delete_recurring(recurring_id):\n    recurring = RecurringTransaction.query.get_or_404(recurring_id)\n    \n    if recurring.user_id != current_user.id:\n        flash('You do not have permission to delete this recurring transaction.', 'danger')\n        return redirect(url_for('recurring.index'))\n    \n    db.session.delete(recurring)\n    db.session.commit()\n    \n    flash('Recurring transaction deleted successfully!', 'success')\n    return redirect(url_for('recurring.index'))\n\n\n@recurring_bp.route('/recurring/generate/<int:recurring_id>', methods=['POST'])\n@login_required\ndef generate_now(recurring_id):\n    recurring = RecurringTransaction.query.get_or_404(recurring_id)\n    \n    if recurring.user_id != current_user.id:\n        flash('You do not have permission to generate this transaction.', 'danger')\n        return redirect(url_for('recurring.index'))\n    \n    if not recurring.is_active:\n        flash('This recurring transaction is inactive.', 'danger')\n        return redirect(url_for('recurring.index'))\n    \n    target_date = recurring.get_next_date()\n    \n    if recurring.end_date and target_date > recurring.end_date:\n        flash('This recurring transaction has ended.', 'danger')\n        return redirect(url_for('recurring.index'))\n    \n    transaction = recurring.generate_transaction(target_date)\n    if transaction:\n        db.session.add(transaction)\n        recurring.last_generated = target_date\n        db.session.commit()\n        flash(f'Transaction generated successfully for {target_date}!', 'success')\n    else:\n        flash('Unable to generate transaction.', 'danger')\n    \n    return redirect(url_for('recurring.index'))\n","size_bytes":7319},"models/user.py":{"content":"from app import db\nfrom flask_login import UserMixin\nfrom werkzeug.security import generate_password_hash, check_password_hash\n\n\nclass User(UserMixin, db.Model):\n    __tablename__ = 'users'\n    \n    id = db.Column(db.Integer, primary_key=True)\n    username = db.Column(db.String(64), unique=True, nullable=False, index=True)\n    email = db.Column(db.String(120), unique=True, nullable=False, index=True)\n    password_hash = db.Column(db.String(256), nullable=False)\n    \n    transactions = db.relationship('Transaction', backref='user', lazy='dynamic', cascade='all, delete-orphan')\n    \n    def set_password(self, password):\n        self.password_hash = generate_password_hash(password)\n    \n    def check_password(self, password):\n        return check_password_hash(self.password_hash, password)\n    \n    def __repr__(self):\n        return f'<User {self.username}>'\n","size_bytes":868},"design_guidelines.md":{"content":"# SmartFinanceAI Design Guidelines\n\n## Design Approach\n**System-Based Approach**: Drawing from Material Design principles and financial app leaders (Mint, YNAB, Stripe Dashboard) for clarity and trust. Focus on data legibility, hierarchical information display, and professional credibility.\n\n## Core Design Elements\n\n### Typography\n- **Primary Font**: Inter (Google Fonts) - clean, highly legible for data\n- **Headings**: \n  - H1: text-3xl font-bold (Dashboard titles, page headers)\n  - H2: text-2xl font-semibold (Section headers)\n  - H3: text-xl font-medium (Card titles, sub-sections)\n- **Body**: text-base (Transaction descriptions, form labels)\n- **Data/Numbers**: text-lg font-semibold (Financial amounts, stats)\n- **Small Text**: text-sm (Helper text, timestamps)\n\n### Layout System\n**Spacing Primitives**: Consistent use of p-4, p-6, p-8 for padding; gap-4, gap-6 for grids; mb-4, mb-6, mb-8 for margins.\n- **Container**: max-w-7xl mx-auto px-4\n- **Dashboard Grid**: 3-column stats cards on desktop (grid-cols-1 md:grid-cols-3 gap-6)\n- **Content Cards**: Rounded corners (rounded-lg), subtle shadows (shadow-md)\n\n### Component Library\n\n**Navigation**\n- Top navbar with logo left, user menu right\n- Includes: Dashboard, Transactions, Add Transaction, Insights, Logout\n- Fixed position with subtle bottom border\n\n**Authentication Pages (Login/Register)**\n- Centered card layout (max-w-md mx-auto)\n- Clean form with generous spacing between fields\n- Primary CTA button prominent at bottom\n- Link to alternate auth page below\n\n**Dashboard Components**\n1. **Stats Cards** (Income/Expense/Balance)\n   - Large number display (text-3xl font-bold)\n   - Icon + label above number\n   - Subtle background treatment\n   - Green for income, red for expense, blue for balance indicators\n\n2. **Transaction List**\n   - Table format with alternating row backgrounds\n   - Columns: Date, Category, Description, Amount, Type\n   - Amount right-aligned with income/expense color coding\n   - Recent 10 transactions shown with \"View All\" link\n\n3. **Charts Section**\n   - 2-column layout on desktop (Pie chart + Line chart)\n   - Chart.js with clean, minimal styling\n   - Pie chart: Category breakdown with legend\n   - Line chart: Monthly spending trends\n\n4. **AI Insights Panel**\n   - Prominent card with icon\n   - Bullet list of insights with icons\n   - Distinct visual treatment (subtle border accent)\n\n**Add Transaction Form**\n- Single-column centered form (max-w-2xl)\n- Clear field labels above inputs\n- Dropdown for type (Income/Expense) and category\n- Date picker, amount input (with currency symbol)\n- Text area for description\n- Large \"Add Transaction\" button\n\n**Forms & Inputs**\n- Consistent padding (px-4 py-2)\n- Border treatment with focus states\n- Labels above inputs (font-medium mb-2)\n- Helper text below when needed (text-sm text-gray-600)\n- Error states with red accent\n\n**Buttons**\n- Primary: Solid fill, rounded-md, px-6 py-2\n- Secondary: Outline style\n- Hover states with subtle transform\n\n### Visual Hierarchy\n- Financial amounts are ALWAYS prominent (larger, bolder)\n- Category badges use pill shapes (rounded-full px-3 py-1)\n- Icons consistently 20px or 24px\n- Critical actions (Add Transaction) use larger buttons\n\n### Data Visualization\n- Chart.js with consistent color palette across all charts\n- Tooltips enabled for interactive data exploration\n- Responsive sizing - charts scale with container\n- Legend positioned for clarity without clutter\n\n### Images\n**No hero images required** - This is a dashboard-focused application prioritizing functionality and data clarity over visual storytelling. All pages lead directly to functional content.\n\n### Trust & Credibility Elements\n- Consistent spacing creates professional feel\n- Data precision (show 2 decimal places for amounts)\n- Clear visual separation between sections\n- Timestamp visibility for transaction records\n\n## Animations\n**Minimal approach**: Smooth transitions on hover states only (transition-all duration-200). No distracting animations that interfere with data reading.","size_bytes":4042},"main.py":{"content":"from app import app\n","size_bytes":20},"static/styles.css":{"content":":root {\n    --primary-color: #0066cc;\n    --success-color: #28a745;\n    --danger-color: #dc3545;\n    --warning-color: #ffc107;\n    --info-color: #17a2b8;\n    --light-bg: #f8f9fa;\n    --border-color: #dee2e6;\n}\n\n* {\n    font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;\n}\n\nbody {\n    background-color: #f5f7fa;\n    color: #333;\n}\n\n.navbar {\n    box-shadow: 0 2px 4px rgba(0,0,0,0.05);\n}\n\n.navbar-brand {\n    font-size: 1.25rem;\n    font-weight: 700;\n    color: var(--primary-color) !important;\n}\n\n.nav-link {\n    font-weight: 500;\n    transition: all 0.2s ease;\n}\n\n.nav-link:hover {\n    color: var(--primary-color) !important;\n}\n\n.card {\n    border: none;\n    border-radius: 12px;\n    box-shadow: 0 2px 8px rgba(0,0,0,0.08);\n    transition: all 0.2s ease;\n}\n\n.card:hover {\n    box-shadow: 0 4px 12px rgba(0,0,0,0.12);\n}\n\n.stat-card {\n    border-left: 4px solid;\n}\n\n.income-card {\n    border-left-color: var(--success-color);\n    background: linear-gradient(135deg, #ffffff 0%, #f0fff4 100%);\n}\n\n.expense-card {\n    border-left-color: var(--danger-color);\n    background: linear-gradient(135deg, #ffffff 0%, #fff5f5 100%);\n}\n\n.balance-card {\n    border-left-color: var(--primary-color);\n    background: linear-gradient(135deg, #ffffff 0%, #f0f7ff 100%);\n}\n\n.stat-icon {\n    font-size: 2rem;\n    opacity: 0.8;\n}\n\n.stat-card h2 {\n    font-size: 2rem;\n    color: #1a1a1a;\n}\n\n.stat-card h6 {\n    font-size: 0.875rem;\n    text-transform: uppercase;\n    letter-spacing: 0.5px;\n    font-weight: 600;\n}\n\n.table {\n    font-size: 0.95rem;\n}\n\n.table thead th {\n    background-color: #f8f9fa;\n    color: #6c757d;\n    font-weight: 600;\n    font-size: 0.875rem;\n    text-transform: uppercase;\n    letter-spacing: 0.5px;\n    border-bottom: 2px solid var(--border-color);\n}\n\n.table tbody tr {\n    transition: all 0.2s ease;\n}\n\n.table tbody tr:hover {\n    background-color: #f8f9fa;\n}\n\n.badge {\n    font-weight: 500;\n    padding: 0.35em 0.75em;\n    border-radius: 6px;\n}\n\n.btn {\n    border-radius: 8px;\n    font-weight: 500;\n    padding: 0.5rem 1.25rem;\n    transition: all 0.2s ease;\n}\n\n.btn-primary {\n    background-color: var(--primary-color);\n    border-color: var(--primary-color);\n}\n\n.btn-primary:hover {\n    background-color: #0052a3;\n    border-color: #0052a3;\n    transform: translateY(-1px);\n    box-shadow: 0 4px 8px rgba(0,102,204,0.2);\n}\n\n.btn-outline-primary:hover {\n    background-color: var(--primary-color);\n    border-color: var(--primary-color);\n    transform: translateY(-1px);\n}\n\n.form-label {\n    font-weight: 500;\n    color: #495057;\n    margin-bottom: 0.5rem;\n}\n\n.form-control, .form-select {\n    border-radius: 8px;\n    border: 1px solid var(--border-color);\n    padding: 0.625rem 1rem;\n    transition: all 0.2s ease;\n}\n\n.form-control:focus, .form-select:focus {\n    border-color: var(--primary-color);\n    box-shadow: 0 0 0 0.2rem rgba(0,102,204,0.15);\n}\n\n.insights-card {\n    border-left: 4px solid var(--info-color);\n}\n\n.insight-item {\n    border-left: 3px solid;\n    transition: all 0.2s ease;\n}\n\n.insight-item:hover {\n    transform: translateX(4px);\n}\n\n.bg-warning-subtle {\n    background-color: #fff3cd !important;\n    border-left-color: var(--warning-color);\n}\n\n.bg-success-subtle {\n    background-color: #d4edda !important;\n    border-left-color: var(--success-color);\n}\n\n.bg-info-subtle {\n    background-color: #d1ecf1 !important;\n    border-left-color: var(--info-color);\n}\n\n.card-header {\n    border-bottom: 2px solid var(--border-color);\n    padding: 1rem 1.5rem;\n}\n\n.card-title {\n    color: #1a1a1a;\n    font-size: 1.125rem;\n}\n\n.text-success {\n    color: var(--success-color) !important;\n}\n\n.text-danger {\n    color: var(--danger-color) !important;\n}\n\n.alert {\n    border-radius: 8px;\n    border: none;\n    font-weight: 500;\n}\n\n.dropdown-menu {\n    border-radius: 8px;\n    border: none;\n    box-shadow: 0 4px 12px rgba(0,0,0,0.15);\n}\n\n.dropdown-item {\n    transition: all 0.2s ease;\n    font-weight: 500;\n}\n\n.dropdown-item:hover {\n    background-color: #f8f9fa;\n    color: var(--primary-color);\n}\n\n@media (max-width: 768px) {\n    .stat-card h2 {\n        font-size: 1.5rem;\n    }\n    \n    .table {\n        font-size: 0.875rem;\n    }\n}\n\ncanvas {\n    max-height: 300px;\n}\n\n.shadow-lg {\n    box-shadow: 0 8px 24px rgba(0,0,0,0.12) !important;\n}\n\n.shadow-sm {\n    box-shadow: 0 2px 8px rgba(0,0,0,0.08) !important;\n}\n\n/* Landing Page Styles */\n.hero-section {\n    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);\n    color: white;\n    padding: 100px 0;\n    min-height: 600px;\n    display: flex;\n    align-items: center;\n}\n\n.hero-title {\n    font-size: 3.5rem;\n    font-weight: 800;\n    margin-bottom: 1.5rem;\n    line-height: 1.2;\n}\n\n.hero-subtitle {\n    font-size: 1.25rem;\n    margin-bottom: 2rem;\n    opacity: 0.95;\n    max-width: 600px;\n}\n\n.hero-btn {\n    padding: 15px 40px;\n    font-size: 1.1rem;\n    border-radius: 50px;\n    font-weight: 600;\n    transition: all 0.3s ease;\n}\n\n.hero-btn:hover {\n    transform: translateY(-2px);\n    box-shadow: 0 10px 25px rgba(0,0,0,0.2);\n}\n\n.hero-terms {\n    font-size: 0.9rem;\n    opacity: 0.9;\n}\n\n.features-section {\n    padding: 80px 0;\n    background: #f8f9fa;\n}\n\n.feature-card {\n    background: white;\n    border-radius: 16px;\n    padding: 2.5rem;\n    height: 100%;\n    transition: all 0.3s ease;\n    border: none;\n    box-shadow: 0 4px 12px rgba(0,0,0,0.08);\n}\n\n.feature-card:hover {\n    transform: translateY(-8px);\n    box-shadow: 0 12px 24px rgba(0,0,0,0.15);\n}\n\n.feature-icon {\n    font-size: 3rem;\n    margin-bottom: 1.5rem;\n}\n\n.feature-title {\n    font-size: 1.5rem;\n    font-weight: 700;\n    margin-bottom: 1rem;\n    color: #1a1a1a;\n}\n\n.feature-text {\n    color: #6c757d;\n    line-height: 1.7;\n}\n\n.section-title {\n    font-size: 2.5rem;\n    font-weight: 800;\n    margin-bottom: 3rem;\n    color: #1a1a1a;\n}\n\n.section-subtitle {\n    font-size: 1.1rem;\n    max-width: 700px;\n    margin: 0 auto 3rem;\n}\n\n.faq-section {\n    padding: 80px 0;\n    background: white;\n}\n\n.faq-item {\n    margin-bottom: 2rem;\n}\n\n.faq-question {\n    font-size: 1.25rem;\n    font-weight: 700;\n    margin-bottom: 1rem;\n    color: #1a1a1a;\n}\n\n.faq-answer {\n    color: #6c757d;\n    line-height: 1.7;\n}\n\n.cta-section {\n    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);\n    color: white;\n    padding: 80px 0;\n}\n\n.cta-title {\n    font-size: 2.5rem;\n    font-weight: 800;\n}\n\n.cta-subtitle {\n    font-size: 1.2rem;\n    opacity: 0.95;\n}\n\n.footer {\n    background: #1a1a1a;\n    color: #adb5bd;\n    padding: 40px 0 20px 0;\n}\n\n.footer a {\n    color: #adb5bd;\n    text-decoration: none;\n    transition: color 0.2s ease;\n}\n\n.footer a:hover {\n    color: white;\n}\n\n.footer-brand {\n    font-size: 1.5rem;\n    font-weight: 700;\n    color: white;\n    margin-bottom: 1rem;\n}\n\n.footer-section-title {\n    color: white;\n    margin-bottom: 1rem;\n}\n\n.footer-divider {\n    border-color: #495057;\n}\n\n@media (max-width: 768px) {\n    .hero-title {\n        font-size: 2.5rem;\n    }\n    \n    .hero-subtitle {\n        font-size: 1.1rem;\n    }\n    \n    .section-title {\n        font-size: 2rem;\n    }\n    \n    .cta-title {\n        font-size: 2rem;\n    }\n}\n","size_bytes":7159},"routes/api.py":{"content":"from flask import Blueprint, request, jsonify\nfrom flask_login import login_required, current_user, login_user\nfrom app import db\nfrom models.user import User\nfrom models.transaction import Transaction\nfrom services.ai_insights import get_ai_insights\nfrom datetime import datetime\n\napi_bp = Blueprint('api', __name__, url_prefix='/api/v1')\n\n\n@api_bp.route('/auth/register', methods=['POST'])\ndef api_register():\n    data = request.get_json()\n    \n    if not data or not data.get('username') or not data.get('email') or not data.get('password'):\n        return jsonify({'error': 'Missing required fields'}), 400\n    \n    username = data.get('username')\n    email = data.get('email')\n    password = data.get('password')\n    \n    if User.query.filter_by(username=username).first():\n        return jsonify({'error': 'Username already exists'}), 400\n    \n    if User.query.filter_by(email=email).first():\n        return jsonify({'error': 'Email already registered'}), 400\n    \n    user = User(username=username, email=email)\n    user.set_password(password)\n    db.session.add(user)\n    db.session.commit()\n    \n    return jsonify({\n        'message': 'User registered successfully',\n        'user': {\n            'id': user.id,\n            'username': user.username,\n            'email': user.email\n        }\n    }), 201\n\n\n@api_bp.route('/auth/login', methods=['POST'])\ndef api_login():\n    data = request.get_json()\n    \n    if not data or not data.get('username') or not data.get('password'):\n        return jsonify({'error': 'Missing username or password'}), 400\n    \n    user = User.query.filter_by(username=data.get('username')).first()\n    \n    if user is None or not user.check_password(data.get('password')):\n        return jsonify({'error': 'Invalid credentials'}), 401\n    \n    login_user(user)\n    \n    return jsonify({\n        'message': 'Login successful',\n        'user': {\n            'id': user.id,\n            'username': user.username,\n            'email': user.email\n        }\n    }), 200\n\n\n@api_bp.route('/transactions', methods=['GET'])\n@login_required\ndef api_get_transactions():\n    transactions = Transaction.query.filter_by(user_id=current_user.id).order_by(Transaction.date.desc()).all()\n    \n    return jsonify({\n        'transactions': [t.to_dict() for t in transactions]\n    }), 200\n\n\n@api_bp.route('/transactions/create', methods=['POST'])\n@login_required\ndef api_create_transaction():\n    data = request.get_json()\n    \n    if not data or not all(k in data for k in ['transaction_type', 'category', 'amount', 'date']):\n        return jsonify({'error': 'Missing required fields'}), 400\n    \n    try:\n        amount = float(data.get('amount'))\n        if amount <= 0:\n            return jsonify({'error': 'Amount must be greater than zero'}), 400\n    except (ValueError, TypeError):\n        return jsonify({'error': 'Invalid amount format'}), 400\n    \n    try:\n        date_obj = datetime.strptime(data.get('date'), '%Y-%m-%d').date()\n    except ValueError:\n        return jsonify({'error': 'Invalid date format. Use YYYY-MM-DD'}), 400\n    \n    transaction = Transaction(\n        user_id=current_user.id,\n        transaction_type=data.get('transaction_type'),\n        category=data.get('category'),\n        amount=amount,\n        description=data.get('description', ''),\n        date=date_obj\n    )\n    \n    db.session.add(transaction)\n    db.session.commit()\n    \n    return jsonify({\n        'message': 'Transaction created successfully',\n        'transaction': transaction.to_dict()\n    }), 201\n\n\n@api_bp.route('/insights', methods=['GET'])\n@login_required\ndef api_get_insights():\n    insights = get_ai_insights(current_user.id)\n    \n    return jsonify({\n        'insights': insights\n    }), 200\n","size_bytes":3723},"replit.md":{"content":"# SmartFinanceAI - Personal Finance Tracker\n\n## Overview\n\nSmartFinanceAI is a Flask-based personal finance management application that helps users track income, expenses, budgets, and recurring transactions. The system provides financial insights through an AI-powered analytics service and offers visual reporting through charts and data exports. Built with Python/Flask, it uses SQLAlchemy ORM for database management and provides both web UI and REST API interfaces.\n\n## User Preferences\n\nPreferred communication style: Simple, everyday language.\n\n## System Architecture\n\n### Frontend Architecture\n\n**Template Engine & UI Framework**\n- **Jinja2** templating for server-side rendering\n- **Bootstrap 5** for responsive component library and grid system\n- **Chart.js** for financial data visualization (category spending, monthly trends)\n- **Inter font** from Google Fonts for clean typography optimized for financial data display\n\n**Design System**\n- Material Design-inspired approach focused on data legibility and trust\n- Consistent spacing primitives (p-4, p-6, p-8 for padding; gap-4, gap-6 for grids)\n- Three-column responsive grid for dashboard stats (grid-cols-1 md:grid-cols-3)\n- Color-coded financial indicators (green for income, red for expense, blue for balance)\n- Custom CSS variables for theme consistency (--primary-color, --success-color, etc.)\n\n### Backend Architecture\n\n**Web Framework**\n- **Flask** as the core web framework with blueprint-based modular routing\n- **Flask-Login** for session-based user authentication and authorization\n- **ProxyFix** middleware for handling reverse proxy headers (x_proto, x_host)\n\n**Application Structure**\n- Factory pattern via `create_app()` for application initialization\n- Blueprint organization by feature domain:\n  - `auth_bp`: User authentication (login, register, logout)\n  - `dashboard_bp`: Main dashboard and transaction management\n  - `api_bp`: RESTful API endpoints (v1 prefixed)\n  - `budgets_bp`: Budget creation and tracking\n  - `reports_bp`: Financial reports and CSV export\n  - `recurring_bp`: Recurring transaction management\n\n**Authentication Flow**\n- Password hashing using Werkzeug's `generate_password_hash` and `check_password_hash`\n- Session-based authentication with login redirects for protected routes\n- User loader function for Flask-Login integration\n\n### Data Layer\n\n**ORM & Models**\n- **SQLAlchemy** with declarative base for object-relational mapping\n- Connection pooling with `pool_recycle` (300s) and `pool_pre_ping` for reliability\n\n**Database Schema**\n- **Users**: Core authentication table with username, email, password_hash\n- **Transactions**: Financial records with user_id (FK), amount, category, type, date, description\n  - Indexed on user_id and date for query performance\n  - Cascade deletion when user is deleted\n- **Budgets**: Category-based spending limits with period (monthly/weekly/yearly)\n  - Unique constraint on (user_id, category, period) to prevent duplicates\n- **RecurringTransactions**: Automated transaction templates with frequency patterns\n  - Supports daily, weekly, biweekly, monthly, yearly frequencies\n  - Tracks last_generated date and active status\n\n**Query Patterns**\n- Aggregate functions (SUM, COUNT) for financial summaries\n- Date-based filtering and grouping for trend analysis\n- Dynamic relationship queries using SQLAlchemy's `lazy='dynamic'`\n\n### Business Logic Layer\n\n**AI Insights Service** (`services/ai_insights.py`)\n- Spending trend analysis comparing recent months\n- Savings rate calculation and personalized recommendations\n- Top spending category identification\n- Rule-based insights (not external AI API integration)\n\n**Budget Tracking**\n- Real-time spending calculation against budget limits\n- Period-based filtering (monthly, weekly, yearly)\n- Visual progress indicators with status thresholds (danger >100%, warning >80%, success <80%)\n\n**Recurring Transactions**\n- Date calculation engine for next occurrence based on frequency\n- Handles edge cases (month-end dates, leap years)\n- Active/inactive status management\n\n### API Design\n\n**REST Endpoints** (`/api/v1/*`)\n- `POST /auth/register`: User registration with validation\n- `POST /auth/login`: API-based authentication with session creation\n- `GET /transactions`: List user transactions with filtering\n- `POST /transactions`: Create new transaction\n- Returns JSON responses with appropriate HTTP status codes (200, 201, 400, 404)\n\n**Error Handling**\n- Form validation with flash messages for web UI\n- JSON error responses for API endpoints\n- User-friendly error messages categorized by severity (danger, warning, info, success)\n\n## External Dependencies\n\n### Core Framework Dependencies\n- **Flask**: Web framework (latest stable)\n- **Flask-SQLAlchemy**: ORM integration for Flask\n- **Flask-Login**: User session management\n- **Werkzeug**: WSGI utilities and security helpers\n\n### Database\n- **SQLite**: Embedded database (via SQLAlchemy)\n- Connection string from `DATABASE_URL` environment variable\n- Database file stored in `/instance/smartfinance.db` (auto-created)\n\n### Frontend Libraries (CDN)\n- **Bootstrap 5.3.0**: UI components and responsive grid\n- **Chart.js 4.4.0**: Data visualization library\n- **Google Fonts (Inter)**: Typography\n\n### Configuration Management\n- **Environment Variables**:\n  - `SESSION_SECRET`: Flask session encryption key (falls back to dev key)\n  - `DATABASE_URL`: SQLAlchemy database connection string\n- Configuration class in `config.py` with engine options for connection pooling\n\n### Development & Deployment\n- **Python 3**: Runtime environment\n- **Replit**: Target deployment platform\n- No external API integrations (AI insights are rule-based calculations)","size_bytes":5687},"config.py":{"content":"import os\n\n\nclass Config:\n    SECRET_KEY = os.environ.get('SESSION_SECRET') or 'dev-secret-key-change-in-production'\n    # SQLite database configuration for local system connection\n    SQLALCHEMY_DATABASE_URI = os.environ.get('DATABASE_URL') or 'sqlite:///instance/smartfinance.db'\n    SQLALCHEMY_TRACK_MODIFICATIONS = False\n","size_bytes":325},"models/recurring_transaction.py":{"content":"from app import db\nfrom datetime import datetime, timedelta\nfrom models.transaction import Transaction\n\n\nclass RecurringTransaction(db.Model):\n    __tablename__ = 'recurring_transactions'\n    \n    id = db.Column(db.Integer, primary_key=True)\n    user_id = db.Column(db.Integer, db.ForeignKey('users.id'), nullable=False, index=True)\n    amount = db.Column(db.Float, nullable=False)\n    category = db.Column(db.String(50), nullable=False)\n    transaction_type = db.Column(db.String(20), nullable=False)\n    description = db.Column(db.Text)\n    frequency = db.Column(db.String(20), nullable=False)\n    start_date = db.Column(db.Date, nullable=False)\n    end_date = db.Column(db.Date)\n    last_generated = db.Column(db.Date)\n    is_active = db.Column(db.Boolean, default=True, nullable=False)\n    created_at = db.Column(db.DateTime, default=datetime.utcnow)\n    \n    def get_next_date(self, from_date=None):\n        if not from_date:\n            from_date = self.last_generated or self.start_date\n        \n        if self.frequency == 'daily':\n            return from_date + timedelta(days=1)\n        elif self.frequency == 'weekly':\n            return from_date + timedelta(weeks=1)\n        elif self.frequency == 'biweekly':\n            return from_date + timedelta(weeks=2)\n        elif self.frequency == 'monthly':\n            month = from_date.month + 1\n            year = from_date.year\n            if month > 12:\n                month = 1\n                year += 1\n            day = from_date.day\n            while day > 0:\n                try:\n                    return from_date.replace(year=year, month=month, day=day)\n                except ValueError:\n                    day -= 1\n            return from_date\n        elif self.frequency == 'yearly':\n            try:\n                return from_date.replace(year=from_date.year + 1)\n            except ValueError:\n                return from_date.replace(year=from_date.year + 1, day=28)\n        return from_date\n    \n    def generate_transaction(self, target_date):\n        if self.end_date and target_date > self.end_date:\n            return None\n        \n        transaction = Transaction(\n            user_id=self.user_id,\n            transaction_type=self.transaction_type,\n            category=self.category,\n            amount=self.amount,\n            description=f\"{self.description} (Recurring)\",\n            date=target_date\n        )\n        \n        return transaction\n    \n    def to_dict(self):\n        return {\n            'id': self.id,\n            'user_id': self.user_id,\n            'amount': self.amount,\n            'category': self.category,\n            'transaction_type': self.transaction_type,\n            'description': self.description,\n            'frequency': self.frequency,\n            'start_date': self.start_date.isoformat() if self.start_date else None,\n            'end_date': self.end_date.isoformat() if self.end_date else None,\n            'last_generated': self.last_generated.isoformat() if self.last_generated else None,\n            'is_active': self.is_active,\n            'created_at': self.created_at.isoformat() if self.created_at else None\n        }\n    \n    def __repr__(self):\n        return f'<RecurringTransaction {self.id} - {self.frequency} {self.transaction_type} ${self.amount}>'\n","size_bytes":3296},"services/__init__.py":{"content":"from services.ai_insights import get_ai_insights\n\n__all__ = ['get_ai_insights']\n","size_bytes":80},"routes/reports.py":{"content":"from flask import Blueprint, render_template, request, redirect, url_for, flash, make_response\nfrom flask_login import login_required, current_user\nfrom app import db\nfrom models.transaction import Transaction\nfrom datetime import datetime, date\nfrom sqlalchemy import func\nimport csv\nimport io\n\nreports_bp = Blueprint('reports', __name__)\n\n\n@reports_bp.route('/reports')\n@login_required\ndef index():\n    start_date = request.args.get('start_date')\n    end_date = request.args.get('end_date')\n    category = request.args.get('category')\n    transaction_type = request.args.get('transaction_type')\n    \n    query = Transaction.query.filter_by(user_id=current_user.id)\n    \n    if start_date:\n        try:\n            start_date_obj = datetime.strptime(start_date, '%Y-%m-%d').date()\n            query = query.filter(Transaction.date >= start_date_obj)\n        except ValueError:\n            flash('Invalid start date format.', 'danger')\n    \n    if end_date:\n        try:\n            end_date_obj = datetime.strptime(end_date, '%Y-%m-%d').date()\n            query = query.filter(Transaction.date <= end_date_obj)\n        except ValueError:\n            flash('Invalid end date format.', 'danger')\n    \n    if category and category != 'all':\n        query = query.filter(Transaction.category == category)\n    \n    if transaction_type and transaction_type != 'all':\n        query = query.filter(Transaction.transaction_type == transaction_type)\n    \n    transactions = query.order_by(Transaction.date.desc()).all()\n    \n    total_income = sum(t.amount for t in transactions if t.transaction_type == 'income')\n    total_expense = sum(t.amount for t in transactions if t.transaction_type == 'expense')\n    \n    all_categories = db.session.query(Transaction.category).filter(\n        Transaction.user_id == current_user.id\n    ).distinct().all()\n    categories_list = [cat[0] for cat in all_categories]\n    \n    return render_template('reports.html',\n                         transactions=transactions,\n                         total_income=total_income,\n                         total_expense=total_expense,\n                         balance=total_income - total_expense,\n                         categories=categories_list,\n                         filters={\n                             'start_date': start_date,\n                             'end_date': end_date,\n                             'category': category,\n                             'transaction_type': transaction_type\n                         })\n\n\n@reports_bp.route('/reports/export')\n@login_required\ndef export_csv():\n    start_date = request.args.get('start_date')\n    end_date = request.args.get('end_date')\n    category = request.args.get('category')\n    transaction_type = request.args.get('transaction_type')\n    \n    query = Transaction.query.filter_by(user_id=current_user.id)\n    \n    start_date_obj = None\n    end_date_obj = None\n    \n    if start_date:\n        try:\n            start_date_obj = datetime.strptime(start_date, '%Y-%m-%d').date()\n            query = query.filter(Transaction.date >= start_date_obj)\n        except ValueError:\n            flash('Invalid start date format.', 'danger')\n            return redirect(url_for('reports.index'))\n    \n    if end_date:\n        try:\n            end_date_obj = datetime.strptime(end_date, '%Y-%m-%d').date()\n            query = query.filter(Transaction.date <= end_date_obj)\n        except ValueError:\n            flash('Invalid end date format.', 'danger')\n            return redirect(url_for('reports.index'))\n    \n    if category and category != 'all':\n        query = query.filter(Transaction.category == category)\n    \n    if transaction_type and transaction_type != 'all':\n        query = query.filter(Transaction.transaction_type == transaction_type)\n    \n    transactions = query.order_by(Transaction.date.desc()).all()\n    \n    output = io.StringIO()\n    writer = csv.writer(output)\n    \n    writer.writerow(['Date', 'Category', 'Description', 'Type', 'Amount'])\n    \n    for transaction in transactions:\n        writer.writerow([\n            transaction.date.strftime('%Y-%m-%d'),\n            transaction.category,\n            transaction.description or '',\n            transaction.transaction_type.capitalize(),\n            f'{transaction.amount:.2f}'\n        ])\n    \n    writer.writerow([])\n    writer.writerow(['Summary'])\n    total_income = sum(t.amount for t in transactions if t.transaction_type == 'income')\n    total_expense = sum(t.amount for t in transactions if t.transaction_type == 'expense')\n    writer.writerow(['Total Income', f'{total_income:.2f}'])\n    writer.writerow(['Total Expenses', f'{total_expense:.2f}'])\n    writer.writerow(['Balance', f'{total_income - total_expense:.2f}'])\n    \n    output.seek(0)\n    \n    response = make_response(output.getvalue())\n    response.headers['Content-Disposition'] = 'attachment; filename=transactions_report.csv'\n    response.headers['Content-Type'] = 'text/csv'\n    \n    return response\n","size_bytes":4980},"models/__init__.py":{"content":"from models.user import User\nfrom models.transaction import Transaction\nfrom models.budget import Budget\nfrom models.recurring_transaction import RecurringTransaction\n\n__all__ = ['User', 'Transaction', 'Budget', 'RecurringTransaction']\n","size_bytes":236},"routes/auth.py":{"content":"from flask import Blueprint, render_template, request, redirect, url_for, flash\nfrom flask_login import login_user, logout_user, login_required, current_user\nfrom app import db\nfrom models.user import User\n\nauth_bp = Blueprint('auth', __name__)\n\n\n@auth_bp.route('/register', methods=['GET', 'POST'])\ndef register():\n    if current_user.is_authenticated:\n        return redirect(url_for('dashboard.index'))\n    \n    if request.method == 'POST':\n        username = request.form.get('username')\n        email = request.form.get('email')\n        password = request.form.get('password')\n        \n        if not username or not email or not password:\n            flash('All fields are required.', 'danger')\n            return render_template('register.html')\n        \n        if User.query.filter_by(username=username).first():\n            flash('Username already exists.', 'danger')\n            return render_template('register.html')\n        \n        if User.query.filter_by(email=email).first():\n            flash('Email already registered.', 'danger')\n            return render_template('register.html')\n        \n        user = User(username=username, email=email)\n        user.set_password(password)\n        db.session.add(user)\n        db.session.commit()\n        \n        flash('Registration successful! Please login.', 'success')\n        return redirect(url_for('auth.login'))\n    \n    return render_template('register.html')\n\n\n@auth_bp.route('/login', methods=['GET', 'POST'])\ndef login():\n    if current_user.is_authenticated:\n        return redirect(url_for('dashboard.index'))\n    \n    if request.method == 'POST':\n        username = request.form.get('username')\n        password = request.form.get('password')\n        \n        if not username or not password:\n            flash('Please provide both username and password.', 'danger')\n            return render_template('login.html')\n        \n        user = User.query.filter_by(username=username).first()\n        \n        if user is None or not user.check_password(password):\n            flash('Invalid username or password.', 'danger')\n            return render_template('login.html')\n        \n        login_user(user)\n        flash(f'Welcome back, {user.username}!', 'success')\n        \n        next_page = request.args.get('next')\n        if next_page:\n            return redirect(next_page)\n        return redirect(url_for('dashboard.index'))\n    \n    return render_template('login.html')\n\n\n@auth_bp.route('/logout')\n@login_required\ndef logout():\n    logout_user()\n    flash('You have been logged out.', 'info')\n    return redirect(url_for('auth.login'))\n","size_bytes":2616},"services/pdf_parser.py":{"content":"import re\nfrom datetime import datetime\nfrom pypdf import PdfReader\n\n\ndef parse_transaction_pdf(pdf_file):\n    \"\"\"\n    Parse a PDF file and extract transaction data.\n    Returns a list of transaction dictionaries.\n    \n    Expected PDF format:\n    - Each transaction should contain: date, description, amount, type (income/expense)\n    - Supports common bank statement formats\n    \"\"\"\n    transactions = []\n    \n    try:\n        pdf_reader = PdfReader(pdf_file)\n        text = \"\"\n        \n        for page in pdf_reader.pages:\n            text += page.extract_text()\n        \n        lines = text.split('\\n')\n        \n        for line in lines:\n            line = line.strip()\n            if not line:\n                continue\n            \n            transaction = parse_transaction_line(line)\n            if transaction:\n                transactions.append(transaction)\n        \n        return transactions\n    \n    except Exception as e:\n        raise Exception(f\"Error parsing PDF: {str(e)}\")\n\n\ndef parse_transaction_line(line):\n    \"\"\"\n    Parse a single line from PDF to extract transaction details.\n    Supports multiple date formats and transaction patterns.\n    \"\"\"\n    date_patterns = [\n        r'\\d{1,2}[-/]\\d{1,2}[-/]\\d{2,4}',\n        r'\\d{4}[-/]\\d{1,2}[-/]\\d{1,2}',\n        r'\\d{1,2}\\s+(?:Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)[a-z]*\\s+\\d{2,4}'\n    ]\n    \n    amount_pattern = r'[â‚¹$]?\\s*[\\d,]+\\.?\\d{0,2}'\n    \n    for date_pattern in date_patterns:\n        date_match = re.search(date_pattern, line, re.IGNORECASE)\n        if date_match:\n            date_str = date_match.group()\n            amount_matches = re.findall(amount_pattern, line)\n            \n            if amount_matches:\n                try:\n                    date_obj = parse_date(date_str)\n                    \n                    amount_str = amount_matches[-1].replace('â‚¹', '').replace('$', '').replace(',', '').strip()\n                    amount = float(amount_str)\n                    \n                    description = line.replace(date_str, '').strip()\n                    for amt in amount_matches:\n                        description = description.replace(amt, '').strip()\n                    \n                    description = ' '.join(description.split())\n                    \n                    if len(description) > 5:\n                        transaction_type = 'expense'\n                        category = categorize_transaction(description)\n                        \n                        return {\n                            'date': date_obj,\n                            'description': description[:100],\n                            'amount': amount,\n                            'transaction_type': transaction_type,\n                            'category': category\n                        }\n                \n                except (ValueError, Exception):\n                    continue\n    \n    return None\n\n\ndef parse_date(date_str):\n    \"\"\"Parse various date formats.\"\"\"\n    date_formats = [\n        '%d-%m-%Y',\n        '%d/%m/%Y',\n        '%Y-%m-%d',\n        '%Y/%m/%d',\n        '%d-%m-%y',\n        '%d/%m/%y',\n        '%d %b %Y',\n        '%d %B %Y'\n    ]\n    \n    for fmt in date_formats:\n        try:\n            return datetime.strptime(date_str, fmt).date()\n        except ValueError:\n            continue\n    \n    return datetime.now().date()\n\n\ndef categorize_transaction(description):\n    \"\"\"Automatically categorize transaction based on description.\"\"\"\n    description_lower = description.lower()\n    \n    categories = {\n        'Food & Dining': ['restaurant', 'cafe', 'food', 'dining', 'swiggy', 'zomato', 'uber eats', 'dominos', 'pizza', 'mcdonald'],\n        'Transportation': ['uber', 'ola', 'taxi', 'metro', 'bus', 'train', 'fuel', 'petrol', 'diesel', 'parking'],\n        'Shopping': ['amazon', 'flipkart', 'myntra', 'mall', 'store', 'shopping', 'purchase'],\n        'Entertainment': ['movie', 'cinema', 'netflix', 'spotify', 'prime', 'hotstar', 'game'],\n        'Utilities': ['electricity', 'water', 'gas', 'internet', 'phone', 'mobile', 'broadband', 'wifi'],\n        'Healthcare': ['hospital', 'doctor', 'medical', 'pharmacy', 'medicine', 'health'],\n        'Education': ['school', 'college', 'university', 'course', 'book', 'tuition'],\n        'Groceries': ['grocery', 'supermarket', 'reliance fresh', 'big bazaar', 'dmart', 'vegetables'],\n    }\n    \n    for category, keywords in categories.items():\n        for keyword in keywords:\n            if keyword in description_lower:\n                return category\n    \n    return 'Others'\n","size_bytes":4566}},"version":2}